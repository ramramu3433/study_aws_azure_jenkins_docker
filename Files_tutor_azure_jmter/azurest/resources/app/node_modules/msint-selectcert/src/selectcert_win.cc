/*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *----------------------------------------------------------*/

#include "selectcert.h"

#include <vector>
#include <windows.h>
#include <cryptuiapi.h>

PCCERT_CONTEXT GetCertificateContext(
    LPCSTR lpszCert)
{
    BOOL result = TRUE;
    DWORD cbCertEncoded = 0;
    BYTE* pbCertEncoded = NULL;
    PCCERT_CONTEXT pCertContext = NULL;

    // Determine the size of the certificate as a blob
    result = ::CryptStringToBinary(
        lpszCert,
        0,
        CRYPT_STRING_BASE64HEADER,
        NULL,
        &cbCertEncoded,
        NULL,
        NULL);

    if (!result)
    {
        goto cleanup;
    }

    // Allocate the memory required for the certificate
    pbCertEncoded = new BYTE[cbCertEncoded];

    if (!pbCertEncoded) {
        result = FALSE;
        goto cleanup;
    }

    // Convert the Base64 encoded certificate to a blob
    result = ::CryptStringToBinary(
        lpszCert,
        0,
        CRYPT_STRING_BASE64HEADER,
        pbCertEncoded,
        &cbCertEncoded,
        NULL,
        NULL);

    if (!result)
    {
        goto cleanup;
    }

    // Create the certificate context object from the blob
    pCertContext = ::CertCreateCertificateContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbCertEncoded,
        cbCertEncoded);

    if (!pCertContext)
    {
        result = FALSE;
        goto cleanup;
    }

cleanup:
    if (pbCertEncoded)
    {
        delete[] pbCertEncoded;
    }

    return pCertContext;
}

BOOL AddCertificateContextToStore(
    HCERTSTORE hCertStore,
    HCERTSTORE hCertRefStore,
    PCCERT_CONTEXT pCertContext)
{
    CERT_ID certID;
    PCCERT_CONTEXT pRefCertContext = NULL;
    BOOL result = TRUE;

    // The certificate data provided by the caller is just the certificate and
    // does not include extended properties like an appropriate smartcard logo,
    // so to get those, re-lookup the certificate in the reference store. If it
    // isn't found, we'll just fall back to the provided certificate data.
    certID.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    certID.IssuerSerialNumber.Issuer = pCertContext->pCertInfo->Issuer;
    certID.IssuerSerialNumber.SerialNumber = pCertContext->pCertInfo->SerialNumber;
    pRefCertContext = ::CertFindCertificateInStore(
        hCertRefStore,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,
        CERT_FIND_CERT_ID,
        &certID,
        NULL);

    result = ::CertAddCertificateContextToStore(
        hCertStore,
        pRefCertContext ? pRefCertContext : pCertContext,
        CERT_STORE_ADD_ALWAYS,
        NULL);

    if (!result)
    {
        goto cleanup;
    }

cleanup:
    if (pRefCertContext)
    {
        ::CertFreeCertificateContext(pRefCertContext);
    }

    return result;
}

NAN_METHOD(SelectCertificate)
{
    BOOL result = TRUE;
    HCERTSTORE hCertStore = NULL;
    HCERTSTORE hCertRefStore = NULL;
    std::vector<PCCERT_CONTEXT> certificateContexts;
    v8::Local<v8::Array> certificates;
    uint32_t certificateCount = 0;
    PCCERT_CONTEXT pSelectedCertContext = NULL;
    int32_t selectedIndex = -1;

    // Open an in-memory certificate store to
    // house the certificates for selection.
    hCertStore = ::CertOpenStore(
        CERT_STORE_PROV_MEMORY,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_CREATE_NEW_FLAG,
        NULL);

    if (!hCertStore)
    {
        result = FALSE;
        goto cleanup;
    }

    // Open the "MY" system certificate store from which the certificates were
    // originally read and can be looked up again to get extended properties.
    hCertRefStore = ::CertOpenSystemStore(
        NULL,
        TEXT("MY"));

    if (!hCertRefStore)
    {
        result = FALSE;
        goto cleanup;
    }

    // Convert the input certificate data into certificate contexts
    certificates = info[0].As<v8::Array>();
    certificateCount = certificates->Length();
    for (uint32_t i = 0; i < certificateCount; i++)
    {
        PCCERT_CONTEXT pCertContext = GetCertificateContext(
            *v8::String::Utf8Value(certificates->Get(i)));
        certificateContexts.push_back(pCertContext);
    }

    // Add the certificate contexts to the in-memory store in reverse order.
    // A quirk of the store is that it acts like a stack; you add A, B, C and
    // it gives back C, B, A. Adding in reverse maintains the desired order.
    // Since the certificate count is a uint32_t, it's hard to implement the
    // for loop in reverse since the check of i >= 0 will always be true.
    // So, keep the for loop forward incrementing but use reverse indexes.
    for (uint32_t i = 0; i < certificateCount; i++)
    {
        // If the call to GetCertificateContext failed, it returned NULL and
        // stored that in the certificateContexts vector. In this case, just
        // ignore the supplied certificate as a candidate for selection.
        PCCERT_CONTEXT pCertContext = certificateContexts.at(certificateCount - 1 - i);
        if (pCertContext)
        {
            // This call may also fail, but no big deal. It just means this
            // option won't appear in the dialog. Likely wasn't valid anyway.
            AddCertificateContextToStore(
                hCertStore,
                hCertRefStore,
                pCertContext);
        }
    }

    // Show the certificate selection dialog
    pSelectedCertContext = ::CryptUIDlgSelectCertificateFromStore(
        hCertStore,
        NULL,
        NULL,
        NULL,
        0,
        0,
        NULL);

    // No result is returned if the dialog was canceled
    if (pSelectedCertContext)
    {
        // Locate the index of the returned certificate
        for (uint32_t i = 0; i < certificateCount; i++)
        {
            PCCERT_CONTEXT pCertContext = certificateContexts.at(i);
            if (pCertContext)
            {
                result = ::CertCompareCertificate(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pCertContext->pCertInfo,
                    pSelectedCertContext->pCertInfo);

                if (result) {
                    selectedIndex = i;
                    break;
                }
            }
        }
    }

cleanup:

    if (pSelectedCertContext)
    {
        ::CertFreeCertificateContext(pSelectedCertContext);
    }
    for (size_t i = 0; i < certificateContexts.size(); i++)
    {
        ::CertFreeCertificateContext(certificateContexts.at(i));
    }
    if (hCertRefStore)
    {
        ::CertCloseStore(hCertRefStore, 0);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    info.GetReturnValue().Set(selectedIndex);
}
