{"version":3,"sources":["../pluginHost/xShell/storageProvider.ts"],"names":[],"mappings":"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","file":"xShell/storageProvider.js","sourcesContent":["/*---------------------------------------------------------\r\n * Copyright (C) Microsoft Corporation. All rights reserved.\r\n *--------------------------------------------------------*/\r\n\"use strict\";\r\nimport { Promise } from 'q';\r\nimport * as Q from 'q';\r\nimport * as fs from 'fs';\r\nimport * as _path from 'path';\r\nimport * as uuid from 'node-uuid';\r\nimport * as mkdirp from 'mkdirp';\r\n\r\nimport {IStorageProvider} from \"../interfaces/iStorageProvider\";\r\nimport {FileDialogMode, FileDialogOptions} from \"../common/fileDialogOptions\";\r\nimport {FileOptions, FilePersistence, FileMode, FileAccess} from \"../common/fileOptions\";\r\nimport {SeekOrigin} from \"../common/seekOrigin\";\r\nimport {OpenedFileInfo} from \"../common/openedFileInfo\";\r\n\r\n// Root data path:\r\n// Max OS: /Users/[user_name]/Library/Preferences\r\n// Linux: /home/[user_name]\r\n// Win7+: C:\\Users\\[user_name]\\AppData\\Roaming\r\n// WinXP: C:\\Documents and Settings\\[user_name]\\Application Data\r\nconst RootDataPath: string = process.env.APPDATA || (process.platform === \"darwin\" ? _path.join(process.env.HOME, \"Library/Preferences\") : process.env.HOME)\r\nexport const PermenantStorageRootPath: string = _path.join(RootDataPath, \"ScriptedHost/storage/permenant\");\r\nexport const TemporaryStorageRootPath: string = _path.join(RootDataPath, \"ScriptedHost/storage/temp\");\r\n\r\nexport class StorageProvider implements IStorageProvider {\r\n    private openFiles: {\r\n        [handler: string]: OpenedFileInfo;\r\n    };\r\n\r\n    constructor() {\r\n        this.openFiles = {};\r\n    }\r\n\r\n    public close(streamId: string): Promise<void> {\r\n        var info = this.openFiles[streamId];\r\n        if (info) {\r\n            delete this.openFiles[streamId];\r\n        }\r\n\r\n        return Q.resolve<void>(null);\r\n    }\r\n\r\n    public fileDialog(mode: FileDialogMode, dialogOptions: FileDialogOptions, fileOptions?: FileOptions): Promise<string> {\r\n        try {\r\n            if (!dialogOptions) {\r\n                throw new Error(\"dialogOptions\");\r\n            }\r\n\r\n            if (!fileOptions) {\r\n                throw new Error(\"fileOptions\");\r\n            }\r\n\r\n            // Get the initial directory location.\r\n            // If the path is relative return the path from the current persistence location.\r\n            let initialDirectory = \"\";\r\n            if (_path.isAbsolute(dialogOptions.initialDirectory)) {\r\n                initialDirectory = dialogOptions.initialDirectory;\r\n            } else {\r\n                let rootPath: string = getRootStorageLocation(fileOptions.persistence);\r\n                initialDirectory = _path.join(rootPath, dialogOptions.initialDirectory);\r\n                if (pathExists(initialDirectory)) {\r\n                    initialDirectory = rootPath;\r\n                }\r\n            }\r\n\r\n            let filters = this.getFileFilters(dialogOptions.extensions);\r\n\r\n            switch (mode) {\r\n                case FileDialogMode.open:\r\n                    return this.showOpenDialog(dialogOptions.title, initialDirectory, filters, fileOptions);\r\n                case FileDialogMode.save:\r\n                    return this.showSaveDialog(dialogOptions.title, initialDirectory, filters, fileOptions);\r\n                default:\r\n                    throw new Error(\"Invalid dialog mode\");\r\n            }\r\n        } catch (err) {\r\n            return Q.reject<string>(err);\r\n        }\r\n    }\r\n\r\n    public getFileList(path?: string, persistence?: FilePersistence, index?: number, count?: number): Promise<string[]> {\r\n        path = path ? path : \"\";\r\n\r\n        let deferrer = Q.defer<string[]>();\r\n        try {\r\n            let rootPath: string = getStorageLocation(path, persistence);\r\n            let fileNames: string[] = [];\r\n\r\n            if (pathExists(rootPath)) {\r\n                fs.readdir(rootPath, (err, files) => {\r\n                    if (err) {\r\n                        throw new Error(err.message);\r\n                    } else {\r\n                        files.forEach(fileName => {\r\n                            let filePath = _path.join(rootPath, fileName);\r\n                            // only count file, skip directory\r\n                            if (isFile(filePath)) {\r\n                                fileNames.push(fileName);\r\n                            }\r\n                        });\r\n\r\n                        deferrer.resolve(fileNames);\r\n                    }\r\n                })\r\n            } else {\r\n                throw new Error(\"Path not exist\");\r\n            }\r\n        } catch (err) {\r\n            return Q.reject<string[]>(err);\r\n        }\r\n\r\n        return deferrer.promise.then((files) => {\r\n            // If count is default (0) or negative value, set it to get whole list.\r\n            count = count <= 0 ? files.length : count;\r\n            // If index is negative, set it to 0;\r\n            index = index < 0 ? 0 : index;\r\n            let end = count + index;\r\n            // Get the subset of file list\r\n            return files.slice(index, end);\r\n        });\r\n    }\r\n\r\n    public openFile(path?: string, options?: FileOptions): Promise<string> {\r\n        let streamId: string = uuid.v1();\r\n        try {\r\n            if (!options) {\r\n                throw new Error(\"options\");\r\n            }\r\n\r\n            if (!path) {\r\n                throw new Error(\"Invalid file path\");\r\n            }\r\n\r\n            // Get storage location\r\n            let fullPath: string = getStorageLocation(path, options.persistence);\r\n\r\n            // Get absolute path\r\n            if (!_path.isAbsolute(fullPath)) {\r\n                fullPath = _path.resolve(fullPath);\r\n            }\r\n\r\n            switch (options.mode) {\r\n                case FileMode.append:\r\n                case FileMode.create:\r\n                case FileMode.createNew:\r\n                case FileMode.openOrCreate:\r\n                    // Above modes implies to create new files if not exists, so we check the existence.\r\n                    if (!path && options.persistence == FilePersistence.temporary) {\r\n                        // For temporary files, we accept empty path and we will create a temp file with random name\r\n                        let file: string = generateRandomName();\r\n                        fullPath = _path.join(fullPath, file);\r\n                    }\r\n\r\n                    let directory: string = _path.dirname(fullPath);\r\n                    if (!pathExists(directory)) {\r\n                        // Create directory if not exists\r\n                        mkdirp.sync(directory);\r\n                    }\r\n\r\n                    if (!pathExists(fullPath)) {\r\n                        // Create file if not exists.\r\n                        let fd: number = fs.openSync(fullPath, \"a\");\r\n                        fs.closeSync(fd);\r\n                    } else {\r\n                        // createNew mode expects file to be not exists.\r\n                        if (options.mode === FileMode.createNew) {\r\n                            throw new Error(\"File already exist in 'createNew' mode\");\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                case FileMode.open:\r\n                case FileMode.truncate:\r\n                    // Throw Error when file not exist in above modes\r\n                    if (!pathExists(fullPath)) {\r\n                        throw new Error(\"File does not exist\");\r\n                    }\r\n\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Invalid file mode\");\r\n            }\r\n\r\n            this.openFiles[streamId] = { path: fullPath, options: options, seekOffset: 0, seekFromBeginning: true, content: null };\r\n            if (options.access !== FileAccess.write) {\r\n                // We don't need to create content for write only stream.\r\n                this.openFiles[streamId].content = this.createFileContent(this.openFiles[streamId], this.openFiles[streamId].options.encoding);\r\n            }\r\n\r\n        } catch (err) {\r\n            return Q.reject<string>(err);\r\n        }\r\n\r\n        return Q.resolve(streamId);\r\n    }\r\n\r\n    // TODO: keeping readBinary and readText is just to match the signature in client side. We will remove it eventually.\r\n    public readBinary(streamId: string, count: number): Promise<any> {\r\n        return this.readFile(streamId, count);\r\n    }\r\n\r\n    public readText(streamId: string, count: number): Promise<any> {\r\n        return this.readFile(streamId, count);\r\n    }\r\n\r\n    public seek(streamId: string, offset: number, origin: SeekOrigin): Promise<number> {\r\n        let info: OpenedFileInfo = this.openFiles[streamId];\r\n        let currentOffset = 0;\r\n        try {\r\n            if (info) {\r\n                if (origin === SeekOrigin.end && offset > 0) {\r\n                    // We only support seek backword when seeking from end\r\n                    throw new Error(\"Seek from end not supported\");\r\n                } else if (origin === SeekOrigin.current) {\r\n                    currentOffset = info.seekOffset;\r\n                }\r\n\r\n                currentOffset += offset;\r\n                if (currentOffset < 0) {\r\n                    // Make sure the offset is not going before the  beginning of file.\r\n                    throw new Error(\"Seek before the beginning of file not supported\");\r\n                }\r\n\r\n                info.seekOffset = currentOffset;\r\n                return Q.resolve(info.seekOffset);\r\n            }\r\n\r\n            throw new Error('Unknown stream id');\r\n        } catch (err) {\r\n            return Q.reject<number>(err);\r\n        }\r\n    }\r\n\r\n    // TODO: The reason to keep writeBinary and writeText is to match the call signature in client side. Will remove eventually.\r\n    public writeBinary(streamId: string, data: any, offset: number, count: number): Promise<void> {\r\n        var info = this.openFiles[streamId];\r\n        try {\r\n            if (info) {\r\n                let content = new Buffer(data);\r\n                if (info.seekOffset === 0 && info.seekFromBeginning && offset === 0 && (count === 0 || count === content.length)) {\r\n                    return this.writeFile(info, content)\r\n                        .then(() => {\r\n                            if (info.content) {\r\n                                // Update the content if we are in readWrite mode for future read action\r\n                                info.content = info.content.then(() => {\r\n                                    return content;\r\n                                });\r\n                            }\r\n\r\n                        });\r\n                }\r\n\r\n                throw new Error('Partial file write not supported');\r\n            }\r\n\r\n            throw new Error('Unknown stream id');\r\n        } catch (err) {\r\n            return Q.reject<void>(err);\r\n        }\r\n    }\r\n\r\n    public writeText(streamId: string, data: any, offset: number, count: number): Promise<void> {\r\n        var info = this.openFiles[streamId];\r\n        try {\r\n            if (info) {\r\n                let content = <string>data;\r\n                if (info.seekOffset === 0 && info.seekFromBeginning && offset === 0 && (count === 0 || count === content.length)) {\r\n                    return this.writeFile(info, data)\r\n                        .then(() => {\r\n                            if (info.content) {\r\n                                // Update the content if we are in readWrite mode for future read action\r\n                                info.content = info.content.then(() => {\r\n                                    return content;\r\n                                });\r\n                            }\r\n                        });\r\n                }\r\n\r\n                throw new Error('Partial file write not supported');\r\n            }\r\n\r\n            throw new Error('Unknown stream id');\r\n        } catch (err) {\r\n            return Q.reject<void>(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the file filters for file dialog\r\n     */\r\n    private getFileFilters(extensions: string[]): Electron.FileDialogFilters[] {\r\n        if (extensions) {\r\n            let filters: Electron.FileDialogFilters[] = [];\r\n            extensions.forEach((value, index, array) => {\r\n                // We assume that the extension type here is limited to one. E.g \"Foo file (*.foo)|*.foo\"\r\n                let extensionStrings = value.split(\"|\", 2);\r\n                if (!extensionStrings || extensionStrings.length !== 2) {\r\n                    throw new Error(\"Invalid extension type\");\r\n                }\r\n\r\n                filters.push({ name: extensionStrings[0], extensions: [extensionStrings[1].substring(2)] });\r\n            });\r\n\r\n            return filters;\r\n        }\r\n    }\r\n\r\n    private openFirstSelectedFileFromDialog(fileNames: any, fileOptions: FileOptions, deferrer: Q.Deferred<string>) {\r\n        // Some platform supports multiple selection but we only pick the first one.\r\n        let fileName: string;\r\n        if(!fileNames) {\r\n            // User clicked cancel.\r\n            deferrer.resolve(null);\r\n            return;\r\n        }\r\n\r\n        if(typeof fileNames !== \"string\" && fileNames.length > 0) {\r\n            fileName = fileNames[0];\r\n        } else {\r\n            fileName = fileNames;\r\n        }\r\n\r\n        if (!fileName) {\r\n            deferrer.reject(null);\r\n        } else {\r\n            this.openFile(fileName, fileOptions)\r\n                .then((streamId) => {\r\n                    deferrer.resolve(streamId);\r\n                })\r\n        }\r\n    }\r\n\r\n    private showOpenDialog(title: string, defaultPath: string, filters: Electron.FileDialogFilters[], fileOptions: FileOptions): Promise<string> {\r\n        let deferrer = Q.defer<string>();\r\n        let options: Electron.OpenDialogOptions = {\r\n            title: title,\r\n            defaultPath: defaultPath,\r\n            filters: filters,\r\n            properties: [\"openFile\"]\r\n        };\r\n        try {\r\n            let dialog = require('remote').require('dialog');\r\n            dialog.showOpenDialog(options, (fileNames) => {\r\n                this.openFirstSelectedFileFromDialog(fileNames, fileOptions, deferrer);\r\n            });\r\n        }\r\n        catch (err) {\r\n            // In unit test remote and dialog module are not available\r\n            deferrer.reject(err);\r\n        }\r\n\r\n        return deferrer.promise;\r\n    }\r\n\r\n    private showSaveDialog(title: string, defaultPath: string, filters: Electron.FileDialogFilters[], fileOptions: FileOptions): Promise<string> {\r\n        let deferrer = Q.defer<string>();\r\n        try {\r\n            let dialog = require('remote').require('dialog');\r\n            dialog.showSaveDialog(null, {\r\n                title: title,\r\n                defaultPath: defaultPath,\r\n                filters: filters\r\n            }, (fileNames) => {\r\n                this.openFirstSelectedFileFromDialog(fileNames, fileOptions, deferrer);\r\n            });\r\n        }\r\n        catch (err) {\r\n            deferrer.reject(err);\r\n        }\r\n\r\n        return deferrer.promise;\r\n    }\r\n\r\n    private readFile(streamId: string, count: number): Promise<any> {\r\n        let info: OpenedFileInfo = this.openFiles[streamId];\r\n        try {\r\n            if (info) {\r\n                if (info.options.access === FileAccess.write) {\r\n                    throw new Error(\"File does not have read access\");\r\n                }\r\n\r\n                if (!info.content) {\r\n                    throw new Error(\"Reading file content failed\");\r\n                }\r\n\r\n                return info.content.then((data) => {\r\n                    let start = info.seekOffset;\r\n                    let end = Math.min(start + count, data.length);\r\n                    info.seekOffset = end;\r\n                    // slice content based on count and current offset.\r\n                    return data.slice(start, end);\r\n                });\r\n            }\r\n\r\n            throw new Error(\"Unknown stream id\");\r\n        }\r\n        catch (err) {\r\n            return Q.reject(err);\r\n        }\r\n    }\r\n\r\n    private createFileContent(info: OpenedFileInfo, encoding: string): Promise<any> {\r\n        let deferrer = Q.defer();\r\n        let buildData: (data: string) => any = this.buildStringDate;\r\n        if (encoding && encoding === \"binary\") {\r\n            buildData = this.buildBinaryData;\r\n        }\r\n\r\n        // We use readFile here to read entire content.\r\n        fs.readFile(info.path, { encoding: info.options.encoding, flag: \"r\" }, (err, data) => {\r\n            if (err) {\r\n                throw new Error(err.message);\r\n            } else {\r\n                let result = buildData(data);\r\n                deferrer.resolve(result);\r\n            }\r\n        });\r\n\r\n        return deferrer.promise;\r\n    }\r\n\r\n    private buildBinaryData(data: string): Buffer {\r\n        let buffer = new Buffer(data, \"binary\");\r\n        return buffer;\r\n    }\r\n\r\n    private buildStringDate(data: string): string {\r\n        // TODO: detect for different encoding.\r\n        return data.toString();\r\n    }\r\n\r\n    private writeFile(info: OpenedFileInfo, data: any): Promise<void> {\r\n        if (info.options.access === FileAccess.read) {\r\n            throw new Error(\"File does not have write access\");\r\n        }\r\n\r\n        let deferrer = Q.defer<void>();\r\n        // Write the whole file.\r\n        fs.writeFile(info.path, data, (err) => {\r\n            if (err) {\r\n                throw new Error(err.message);\r\n            }\r\n\r\n            deferrer.resolve(null);\r\n        })\r\n\r\n        return deferrer.promise;\r\n    }\r\n}\r\n\r\n// Below are the static helper functions provided directy by this module\r\n\r\n/**\r\n * Checks if a path exists\r\n */\r\nexport function pathExists(path: string): boolean {\r\n    try {\r\n        fs.statSync(path);\r\n    } catch (err) {\r\n        if (err.code === \"ENOENT\") {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * Normalizes a path.\r\n * It will take care of multiple slashes, \"..\" and \".\", change all \"\\\\\" to \"/\", and delete trailing slash.\r\n */\r\nexport function normalizePath(path: string): string {\r\n    path = _path.normalize(path);\r\n    // Use \"/\" since all platform support it.\r\n    path = path.replace(\"\\\\\", \"/\");\r\n\r\n    if (path.charAt(0) === \"/\") {\r\n        throw new Error(\"Beginning slash not supported\");\r\n    }\r\n\r\n    if (path.charAt(path.length - 1) === \"/\") {\r\n        // Delete trailing slash\r\n        path = path.substring(0, path.length - 1);\r\n    }\r\n\r\n    return path;\r\n}\r\n\r\n/**\r\n * Checks if a path is pointing to a file\r\n */\r\nexport function isFile(path: string): boolean {\r\n    try {\r\n        let stats: fs.Stats = fs.statSync(path);\r\n        return stats.isFile();\r\n    } catch (err) {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets a location based on root storage location.\r\n */\r\nexport function getStorageLocation(path: string, persistence: FilePersistence): string {\r\n    let rootPath: string = getRootStorageLocation(persistence);\r\n    path = normalizePath(path);\r\n    let fullPath: string = _path.isAbsolute(path) ? path : _path.join(rootPath, path);\r\n\r\n\r\n    // Ensure the root path is the base of the full path\r\n    let fromRootToPath = _path.relative(rootPath, fullPath);\r\n    if (fromRootToPath.indexOf(\"..\") !== -1) {\r\n        throw new Error(\"Storage path must be inside of root location\");\r\n    }\r\n\r\n    return fullPath;\r\n}\r\n\r\n/**\r\n * Gets temporary or permanent root storage location\r\n */\r\nexport function getRootStorageLocation(persistence: FilePersistence): string {\r\n    let rootPath = \"\";\r\n\r\n    switch (persistence) {\r\n        case FilePersistence.permanent:\r\n            rootPath = _path.normalize(PermenantStorageRootPath);\r\n            break;\r\n        case FilePersistence.temporary:\r\n            rootPath = _path.normalize(TemporaryStorageRootPath);\r\n            break;\r\n        default:\r\n            throw new Error(\"Invalid persistence\");\r\n    }\r\n\r\n    if (!pathExists(rootPath)) {\r\n        mkdirp.sync(rootPath);\r\n    }\r\n\r\n    return _path.resolve(rootPath);\r\n}\r\n\r\n/**\r\n * Generates randome file name with .tmp extension\r\n */\r\nexport function generateRandomName(): string {\r\n    let prefix = \"daytona_\";\r\n    let extension = \".tmp\";\r\n    let now = new Date();\r\n    let name = prefix +\r\n        now.getFullYear() +\r\n        now.getMonth() +\r\n        now.getDate() +\r\n        \"_\" +\r\n        Math.floor((Math.random() * 999999) + 1).toString(8) +\r\n        extension;\r\n    return name;\r\n}\r\n\r\n"],"sourceRoot":"/source/"}