/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Q = require("q");
var fs = require("fs");
var _path = require("path");
var uuid = require("node-uuid");
var mkdirp = require("mkdirp");
var fileDialogOptions_1 = require("../common/fileDialogOptions");
var fileOptions_1 = require("../common/fileOptions");
var seekOrigin_1 = require("../common/seekOrigin");
// Root data path:
// Max OS: /Users/[user_name]/Library/Preferences
// Linux: /home/[user_name]
// Win7+: C:\Users\[user_name]\AppData\Roaming
// WinXP: C:\Documents and Settings\[user_name]\Application Data
var RootDataPath = process.env.APPDATA || (process.platform === "darwin" ? _path.join(process.env.HOME, "Library/Preferences") : process.env.HOME);
exports.PermenantStorageRootPath = _path.join(RootDataPath, "ScriptedHost/storage/permenant");
exports.TemporaryStorageRootPath = _path.join(RootDataPath, "ScriptedHost/storage/temp");
var StorageProvider = (function () {
    function StorageProvider() {
        this.openFiles = {};
    }
    StorageProvider.prototype.close = function (streamId) {
        var info = this.openFiles[streamId];
        if (info) {
            delete this.openFiles[streamId];
        }
        return Q.resolve(null);
    };
    StorageProvider.prototype.fileDialog = function (mode, dialogOptions, fileOptions) {
        try {
            if (!dialogOptions) {
                throw new Error("dialogOptions");
            }
            if (!fileOptions) {
                throw new Error("fileOptions");
            }
            // Get the initial directory location.
            // If the path is relative return the path from the current persistence location.
            var initialDirectory = "";
            if (_path.isAbsolute(dialogOptions.initialDirectory)) {
                initialDirectory = dialogOptions.initialDirectory;
            }
            else {
                var rootPath = getRootStorageLocation(fileOptions.persistence);
                initialDirectory = _path.join(rootPath, dialogOptions.initialDirectory);
                if (pathExists(initialDirectory)) {
                    initialDirectory = rootPath;
                }
            }
            var filters = this.getFileFilters(dialogOptions.extensions);
            switch (mode) {
                case fileDialogOptions_1.FileDialogMode.open:
                    return this.showOpenDialog(dialogOptions.title, initialDirectory, filters, fileOptions);
                case fileDialogOptions_1.FileDialogMode.save:
                    return this.showSaveDialog(dialogOptions.title, initialDirectory, filters, fileOptions);
                default:
                    throw new Error("Invalid dialog mode");
            }
        }
        catch (err) {
            return Q.reject(err);
        }
    };
    StorageProvider.prototype.getFileList = function (path, persistence, index, count) {
        path = path ? path : "";
        var deferrer = Q.defer();
        try {
            var rootPath_1 = getStorageLocation(path, persistence);
            var fileNames_1 = [];
            if (pathExists(rootPath_1)) {
                fs.readdir(rootPath_1, function (err, files) {
                    if (err) {
                        throw new Error(err.message);
                    }
                    else {
                        files.forEach(function (fileName) {
                            var filePath = _path.join(rootPath_1, fileName);
                            // only count file, skip directory
                            if (isFile(filePath)) {
                                fileNames_1.push(fileName);
                            }
                        });
                        deferrer.resolve(fileNames_1);
                    }
                });
            }
            else {
                throw new Error("Path not exist");
            }
        }
        catch (err) {
            return Q.reject(err);
        }
        return deferrer.promise.then(function (files) {
            // If count is default (0) or negative value, set it to get whole list.
            count = count <= 0 ? files.length : count;
            // If index is negative, set it to 0;
            index = index < 0 ? 0 : index;
            var end = count + index;
            // Get the subset of file list
            return files.slice(index, end);
        });
    };
    StorageProvider.prototype.openFile = function (path, options) {
        var streamId = uuid.v1();
        try {
            if (!options) {
                throw new Error("options");
            }
            if (!path) {
                throw new Error("Invalid file path");
            }
            // Get storage location
            var fullPath = getStorageLocation(path, options.persistence);
            // Get absolute path
            if (!_path.isAbsolute(fullPath)) {
                fullPath = _path.resolve(fullPath);
            }
            switch (options.mode) {
                case fileOptions_1.FileMode.append:
                case fileOptions_1.FileMode.create:
                case fileOptions_1.FileMode.createNew:
                case fileOptions_1.FileMode.openOrCreate:
                    // Above modes implies to create new files if not exists, so we check the existence.
                    if (!path && options.persistence == fileOptions_1.FilePersistence.temporary) {
                        // For temporary files, we accept empty path and we will create a temp file with random name
                        var file = generateRandomName();
                        fullPath = _path.join(fullPath, file);
                    }
                    var directory = _path.dirname(fullPath);
                    if (!pathExists(directory)) {
                        // Create directory if not exists
                        mkdirp.sync(directory);
                    }
                    if (!pathExists(fullPath)) {
                        // Create file if not exists.
                        var fd = fs.openSync(fullPath, "a");
                        fs.closeSync(fd);
                    }
                    else {
                        // createNew mode expects file to be not exists.
                        if (options.mode === fileOptions_1.FileMode.createNew) {
                            throw new Error("File already exist in 'createNew' mode");
                        }
                    }
                    break;
                case fileOptions_1.FileMode.open:
                case fileOptions_1.FileMode.truncate:
                    // Throw Error when file not exist in above modes
                    if (!pathExists(fullPath)) {
                        throw new Error("File does not exist");
                    }
                    break;
                default:
                    throw new Error("Invalid file mode");
            }
            this.openFiles[streamId] = { path: fullPath, options: options, seekOffset: 0, seekFromBeginning: true, content: null };
            if (options.access !== fileOptions_1.FileAccess.write) {
                // We don't need to create content for write only stream.
                this.openFiles[streamId].content = this.createFileContent(this.openFiles[streamId], this.openFiles[streamId].options.encoding);
            }
        }
        catch (err) {
            return Q.reject(err);
        }
        return Q.resolve(streamId);
    };
    // TODO: keeping readBinary and readText is just to match the signature in client side. We will remove it eventually.
    StorageProvider.prototype.readBinary = function (streamId, count) {
        return this.readFile(streamId, count);
    };
    StorageProvider.prototype.readText = function (streamId, count) {
        return this.readFile(streamId, count);
    };
    StorageProvider.prototype.seek = function (streamId, offset, origin) {
        var info = this.openFiles[streamId];
        var currentOffset = 0;
        try {
            if (info) {
                if (origin === seekOrigin_1.SeekOrigin.end && offset > 0) {
                    // We only support seek backword when seeking from end
                    throw new Error("Seek from end not supported");
                }
                else if (origin === seekOrigin_1.SeekOrigin.current) {
                    currentOffset = info.seekOffset;
                }
                currentOffset += offset;
                if (currentOffset < 0) {
                    // Make sure the offset is not going before the  beginning of file.
                    throw new Error("Seek before the beginning of file not supported");
                }
                info.seekOffset = currentOffset;
                return Q.resolve(info.seekOffset);
            }
            throw new Error('Unknown stream id');
        }
        catch (err) {
            return Q.reject(err);
        }
    };
    // TODO: The reason to keep writeBinary and writeText is to match the call signature in client side. Will remove eventually.
    StorageProvider.prototype.writeBinary = function (streamId, data, offset, count) {
        var info = this.openFiles[streamId];
        try {
            if (info) {
                var content_1 = new Buffer(data);
                if (info.seekOffset === 0 && info.seekFromBeginning && offset === 0 && (count === 0 || count === content_1.length)) {
                    return this.writeFile(info, content_1)
                        .then(function () {
                        if (info.content) {
                            // Update the content if we are in readWrite mode for future read action
                            info.content = info.content.then(function () {
                                return content_1;
                            });
                        }
                    });
                }
                throw new Error('Partial file write not supported');
            }
            throw new Error('Unknown stream id');
        }
        catch (err) {
            return Q.reject(err);
        }
    };
    StorageProvider.prototype.writeText = function (streamId, data, offset, count) {
        var info = this.openFiles[streamId];
        try {
            if (info) {
                var content_2 = data;
                if (info.seekOffset === 0 && info.seekFromBeginning && offset === 0 && (count === 0 || count === content_2.length)) {
                    return this.writeFile(info, data)
                        .then(function () {
                        if (info.content) {
                            // Update the content if we are in readWrite mode for future read action
                            info.content = info.content.then(function () {
                                return content_2;
                            });
                        }
                    });
                }
                throw new Error('Partial file write not supported');
            }
            throw new Error('Unknown stream id');
        }
        catch (err) {
            return Q.reject(err);
        }
    };
    /**
     * Gets the file filters for file dialog
     */
    StorageProvider.prototype.getFileFilters = function (extensions) {
        if (extensions) {
            var filters_1 = [];
            extensions.forEach(function (value, index, array) {
                // We assume that the extension type here is limited to one. E.g "Foo file (*.foo)|*.foo"
                var extensionStrings = value.split("|", 2);
                if (!extensionStrings || extensionStrings.length !== 2) {
                    throw new Error("Invalid extension type");
                }
                filters_1.push({ name: extensionStrings[0], extensions: [extensionStrings[1].substring(2)] });
            });
            return filters_1;
        }
    };
    StorageProvider.prototype.openFirstSelectedFileFromDialog = function (fileNames, fileOptions, deferrer) {
        // Some platform supports multiple selection but we only pick the first one.
        var fileName;
        if (!fileNames) {
            // User clicked cancel.
            deferrer.resolve(null);
            return;
        }
        if (typeof fileNames !== "string" && fileNames.length > 0) {
            fileName = fileNames[0];
        }
        else {
            fileName = fileNames;
        }
        if (!fileName) {
            deferrer.reject(null);
        }
        else {
            this.openFile(fileName, fileOptions)
                .then(function (streamId) {
                deferrer.resolve(streamId);
            });
        }
    };
    StorageProvider.prototype.showOpenDialog = function (title, defaultPath, filters, fileOptions) {
        var _this = this;
        var deferrer = Q.defer();
        var options = {
            title: title,
            defaultPath: defaultPath,
            filters: filters,
            properties: ["openFile"]
        };
        try {
            var dialog = require('remote').require('dialog');
            dialog.showOpenDialog(options, function (fileNames) {
                _this.openFirstSelectedFileFromDialog(fileNames, fileOptions, deferrer);
            });
        }
        catch (err) {
            // In unit test remote and dialog module are not available
            deferrer.reject(err);
        }
        return deferrer.promise;
    };
    StorageProvider.prototype.showSaveDialog = function (title, defaultPath, filters, fileOptions) {
        var _this = this;
        var deferrer = Q.defer();
        try {
            var dialog = require('remote').require('dialog');
            dialog.showSaveDialog(null, {
                title: title,
                defaultPath: defaultPath,
                filters: filters
            }, function (fileNames) {
                _this.openFirstSelectedFileFromDialog(fileNames, fileOptions, deferrer);
            });
        }
        catch (err) {
            deferrer.reject(err);
        }
        return deferrer.promise;
    };
    StorageProvider.prototype.readFile = function (streamId, count) {
        var info = this.openFiles[streamId];
        try {
            if (info) {
                if (info.options.access === fileOptions_1.FileAccess.write) {
                    throw new Error("File does not have read access");
                }
                if (!info.content) {
                    throw new Error("Reading file content failed");
                }
                return info.content.then(function (data) {
                    var start = info.seekOffset;
                    var end = Math.min(start + count, data.length);
                    info.seekOffset = end;
                    // slice content based on count and current offset.
                    return data.slice(start, end);
                });
            }
            throw new Error("Unknown stream id");
        }
        catch (err) {
            return Q.reject(err);
        }
    };
    StorageProvider.prototype.createFileContent = function (info, encoding) {
        var deferrer = Q.defer();
        var buildData = this.buildStringDate;
        if (encoding && encoding === "binary") {
            buildData = this.buildBinaryData;
        }
        // We use readFile here to read entire content.
        fs.readFile(info.path, { encoding: info.options.encoding, flag: "r" }, function (err, data) {
            if (err) {
                throw new Error(err.message);
            }
            else {
                var result = buildData(data);
                deferrer.resolve(result);
            }
        });
        return deferrer.promise;
    };
    StorageProvider.prototype.buildBinaryData = function (data) {
        var buffer = new Buffer(data, "binary");
        return buffer;
    };
    StorageProvider.prototype.buildStringDate = function (data) {
        // TODO: detect for different encoding.
        return data.toString();
    };
    StorageProvider.prototype.writeFile = function (info, data) {
        if (info.options.access === fileOptions_1.FileAccess.read) {
            throw new Error("File does not have write access");
        }
        var deferrer = Q.defer();
        // Write the whole file.
        fs.writeFile(info.path, data, function (err) {
            if (err) {
                throw new Error(err.message);
            }
            deferrer.resolve(null);
        });
        return deferrer.promise;
    };
    return StorageProvider;
}());
exports.StorageProvider = StorageProvider;
// Below are the static helper functions provided directy by this module
/**
 * Checks if a path exists
 */
function pathExists(path) {
    try {
        fs.statSync(path);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return false;
        }
    }
    return true;
}
exports.pathExists = pathExists;
;
/**
 * Normalizes a path.
 * It will take care of multiple slashes, ".." and ".", change all "\\" to "/", and delete trailing slash.
 */
function normalizePath(path) {
    path = _path.normalize(path);
    // Use "/" since all platform support it.
    path = path.replace("\\", "/");
    if (path.charAt(0) === "/") {
        throw new Error("Beginning slash not supported");
    }
    if (path.charAt(path.length - 1) === "/") {
        // Delete trailing slash
        path = path.substring(0, path.length - 1);
    }
    return path;
}
exports.normalizePath = normalizePath;
/**
 * Checks if a path is pointing to a file
 */
function isFile(path) {
    try {
        var stats = fs.statSync(path);
        return stats.isFile();
    }
    catch (err) {
        return false;
    }
}
exports.isFile = isFile;
/**
 * Gets a location based on root storage location.
 */
function getStorageLocation(path, persistence) {
    var rootPath = getRootStorageLocation(persistence);
    path = normalizePath(path);
    var fullPath = _path.isAbsolute(path) ? path : _path.join(rootPath, path);
    // Ensure the root path is the base of the full path
    var fromRootToPath = _path.relative(rootPath, fullPath);
    if (fromRootToPath.indexOf("..") !== -1) {
        throw new Error("Storage path must be inside of root location");
    }
    return fullPath;
}
exports.getStorageLocation = getStorageLocation;
/**
 * Gets temporary or permanent root storage location
 */
function getRootStorageLocation(persistence) {
    var rootPath = "";
    switch (persistence) {
        case fileOptions_1.FilePersistence.permanent:
            rootPath = _path.normalize(exports.PermenantStorageRootPath);
            break;
        case fileOptions_1.FilePersistence.temporary:
            rootPath = _path.normalize(exports.TemporaryStorageRootPath);
            break;
        default:
            throw new Error("Invalid persistence");
    }
    if (!pathExists(rootPath)) {
        mkdirp.sync(rootPath);
    }
    return _path.resolve(rootPath);
}
exports.getRootStorageLocation = getRootStorageLocation;
/**
 * Generates randome file name with .tmp extension
 */
function generateRandomName() {
    var prefix = "daytona_";
    var extension = ".tmp";
    var now = new Date();
    var name = prefix +
        now.getFullYear() +
        now.getMonth() +
        now.getDate() +
        "_" +
        Math.floor((Math.random() * 999999) + 1).toString(8) +
        extension;
    return name;
}
exports.generateRandomName = generateRandomName;

//# sourceMappingURL=../xShell/storageProvider.js.map
// SIG // Begin signature block
// SIG // MIIargYJKoZIhvcNAQcCoIIanzCCGpsCAQExCzAJBgUr
// SIG // DgMCGgUAMGcGCisGAQQBgjcCAQSgWTBXMDIGCisGAQQB
// SIG // gjcCAR4wJAIBAQQQEODJBs441BGiowAQS9NQkAIBAAIB
// SIG // AAIBAAIBAAIBADAhMAkGBSsOAwIaBQAEFE9ki21LlZ6C
// SIG // NTU3Y/5fUFCeS17+oIIVgzCCBMMwggOroAMCAQICEzMA
// SIG // AADGeIA2AXUaaXIAAAAAAMYwDQYJKoZIhvcNAQEFBQAw
// SIG // dzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0
// SIG // b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1p
// SIG // Y3Jvc29mdCBDb3Jwb3JhdGlvbjEhMB8GA1UEAxMYTWlj
// SIG // cm9zb2Z0IFRpbWUtU3RhbXAgUENBMB4XDTE2MDkwNzE3
// SIG // NTg1M1oXDTE4MDkwNzE3NTg1M1owgbMxCzAJBgNVBAYT
// SIG // AlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQH
// SIG // EwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29y
// SIG // cG9yYXRpb24xDTALBgNVBAsTBE1PUFIxJzAlBgNVBAsT
// SIG // Hm5DaXBoZXIgRFNFIEVTTjpGNTI4LTM3NzctOEE3NjEl
// SIG // MCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3RhbXAgU2Vy
// SIG // dmljZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
// SIG // ggEBAK0LIxuoyogoFDbjw2hdBoQodUGHEqicqTQCYKGt
// SIG // RrYKDayl0w1GReivnhzzc17/b/y2mC2V9hsjiPZRs+eb
// SIG // V1b9TcuiNbnlYctnFAIXRPiJFUegLQqPAK/Lh8BKZMk4
// SIG // vuGMK+rDhjO2K8AasPknmgYwcDjfvBPEgM9KYJhx4+HD
// SIG // b7eQOkfiEAurcohcfiRDDtaqpyE0iNqsd5Dl4Q98kxeG
// SIG // I40Z08dxxqX2sFAsn1rMWrABx5SCxAH7FQJl7G6+FwAt
// SIG // hwWRil6NN4wJn75m4G5t1eCgStvelJ56fdkWZsABKi9P
// SIG // J/pa5fjxHesOBPZrRR4UfcBkltvQuf9Gzmq/cx8CAwEA
// SIG // AaOCAQkwggEFMB0GA1UdDgQWBBTUv/YysIgxD+YZlPE+
// SIG // vzH6WwIPCTAfBgNVHSMEGDAWgBQjNPjZUkZwCu1A+3b7
// SIG // syuwwzWzDzBUBgNVHR8ETTBLMEmgR6BFhkNodHRwOi8v
// SIG // Y3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0
// SIG // cy9NaWNyb3NvZnRUaW1lU3RhbXBQQ0EuY3JsMFgGCCsG
// SIG // AQUFBwEBBEwwSjBIBggrBgEFBQcwAoY8aHR0cDovL3d3
// SIG // dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNyb3Nv
// SIG // ZnRUaW1lU3RhbXBQQ0EuY3J0MBMGA1UdJQQMMAoGCCsG
// SIG // AQUFBwMIMA0GCSqGSIb3DQEBBQUAA4IBAQCYWwDc76NI
// SIG // i+RQOWeUJMBvj75A3zmmLE2JLKhZPjIKasz8XBcEmDBP
// SIG // 0v8MooXeJcIEOgj3TuQBs95uQ2VO4D0uRXApddJPaU8W
// SIG // eLPOez7vGaxNsa51MlIkBZeQ2Eja6ET7kGEWWV7NsStV
// SIG // lZ9SXMHAMCcH7tZMJ3mzw/dKNQ0ZTaMxxdzTGiKNJwk0
// SIG // QDfOnkgcinWKQ53YKVS0qDdsFJ7IeGy3GaqHeKM3ZL4B
// SIG // kuzdQH9fERBUlAVa2n+zKEsSnjSCiy8oYDcQ8Wca1IJz
// SIG // 298y+98zo+NANSG8N1syaG/L2CvoAWFjkZeI5urwsAKv
// SIG // +fdc/N+BwzR+tFHdGx/sUuz6MIIE7TCCA9WgAwIBAgIT
// SIG // MwAAAUCWqe5wVv7MBwABAAABQDANBgkqhkiG9w0BAQUF
// SIG // ADB5MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGlu
// SIG // Z3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMV
// SIG // TWljcm9zb2Z0IENvcnBvcmF0aW9uMSMwIQYDVQQDExpN
// SIG // aWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQTAeFw0xNjA4
// SIG // MTgyMDE3MTdaFw0xNzExMDIyMDE3MTdaMIGDMQswCQYD
// SIG // VQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G
// SIG // A1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0
// SIG // IENvcnBvcmF0aW9uMQ0wCwYDVQQLEwRNT1BSMR4wHAYD
// SIG // VQQDExVNaWNyb3NvZnQgQ29ycG9yYXRpb24wggEiMA0G
// SIG // CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDbS4vpA2pf
// SIG // yBtdCgU55NUOktDE4YvopA0FGVjAPNcp3Ym3aG5Ln368
// SIG // mr1Uhjmp8Tg1FuYdrPuua9wJMO+4Ht9s+EqaVZdIyCOJ
// SIG // s1knNL2VMUecD85ANTI3/unzT6QapLN5vICbPySYxNFv
// SIG // 1X/nQ43k3PLS5q5m7QQ6IZSmV9wD2yzGG/8rOahdv1X+
// SIG // 3UnfVAWUqzPfpH0xpk29Vs8WMWg/hGscbfPu1TCK7mUb
// SIG // nrcIHCl+k73yfUJ2OCLUe3z0uLlxnsOU9IKGNYKmdL0C
// SIG // M/pUhoWjJb6qiV7iOV8mQZga3rnmRoV4u1EyAkfs5Pkf
// SIG // vQRRdeYSm3brhZcUIgqhE/dhAgMBAAGjggFhMIIBXTAT
// SIG // BgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQUnOXo
// SIG // bYJXrjck3upeqcRfkB3O2XswUgYDVR0RBEswSaRHMEUx
// SIG // DTALBgNVBAsTBE1PUFIxNDAyBgNVBAUTKzIyOTgwMytm
// SIG // Nzg1YjFjMC01ZDlmLTQzMTYtOGQ2YS03NGFlNjQyZGRl
// SIG // MWMwHwYDVR0jBBgwFoAUyxHoytK0FlgByTcuMxYWuUya
// SIG // Ch8wVgYDVR0fBE8wTTBLoEmgR4ZFaHR0cDovL2NybC5t
// SIG // aWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWlj
// SIG // Q29kU2lnUENBXzA4LTMxLTIwMTAuY3JsMFoGCCsGAQUF
// SIG // BwEBBE4wTDBKBggrBgEFBQcwAoY+aHR0cDovL3d3dy5t
// SIG // aWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNDb2RTaWdQ
// SIG // Q0FfMDgtMzEtMjAxMC5jcnQwDQYJKoZIhvcNAQEFBQAD
// SIG // ggEBAGvkVuPXEx0gQPlt6d5O210exmwmo/flCYAM/1fh
// SIG // tNTZ+VxI4QZ/wqRUuJZ69Y3JgxMMcb/4/LsuzBVz8wBr
// SIG // TiWq9MQKcpRSn3dNKZMoCDEW2d9udKvE6E4VsZkFRE4a
// SIG // SUksrHnuv4VPhG5H777Y0otJaQ4pg/WlvaMbIa2ipT6Q
// SIG // IJz1nxI9ell1ZO/ao4WEMhICAmpkdwGmOZiz7qIoSWys
// SIG // JDIoPqiLZiz7AtiDLyOSkfdXZf+k1elRCJT21v3A1cAg
// SIG // Rf1DSU957mQZf2BO4sTKU04f+1qRDVvNJIN8c+jJQncS
// SIG // XzEmybDOU4phVPfCjXKZ8cW2HX6qkIQEOpd5rWAwggW8
// SIG // MIIDpKADAgECAgphMyYaAAAAAAAxMA0GCSqGSIb3DQEB
// SIG // BQUAMF8xEzARBgoJkiaJk/IsZAEZFgNjb20xGTAXBgoJ
// SIG // kiaJk/IsZAEZFgltaWNyb3NvZnQxLTArBgNVBAMTJE1p
// SIG // Y3Jvc29mdCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0
// SIG // eTAeFw0xMDA4MzEyMjE5MzJaFw0yMDA4MzEyMjI5MzJa
// SIG // MHkxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5n
// SIG // dG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVN
// SIG // aWNyb3NvZnQgQ29ycG9yYXRpb24xIzAhBgNVBAMTGk1p
// SIG // Y3Jvc29mdCBDb2RlIFNpZ25pbmcgUENBMIIBIjANBgkq
// SIG // hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsnJZXBkwZL8d
// SIG // mmAgIEKZdlNsPhvWb8zL8epr/pcWEODfOnSDGrcvoDLs
// SIG // /97CQk4j1XIA2zVXConKriBJ9PBorE1LjaW9eUtxm0cH
// SIG // 2v0l3511iM+qc0R/14Hb873yNqTJXEXcr6094Cholxqn
// SIG // pXJzVvEXlOT9NZRyoNZ2Xx53RYOFOBbQc1sFumdSjaWy
// SIG // aS/aGQv+knQp4nYvVN0UMFn40o1i/cvJX0YxULknE+RA
// SIG // MM9yKRAoIsc3Tj2gMj2QzaE4BoVcTlaCKCoFMrdL109j
// SIG // 59ItYvFFPeesCAD2RqGe0VuMJlPoeqpK8kbPNzw4nrR3
// SIG // XKUXno3LEY9WPMGsCV8D0wIDAQABo4IBXjCCAVowDwYD
// SIG // VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUyxHoytK0FlgB
// SIG // yTcuMxYWuUyaCh8wCwYDVR0PBAQDAgGGMBIGCSsGAQQB
// SIG // gjcVAQQFAgMBAAEwIwYJKwYBBAGCNxUCBBYEFP3RMU7T
// SIG // JoqV4ZhgO6gxb6Y8vNgtMBkGCSsGAQQBgjcUAgQMHgoA
// SIG // UwB1AGIAQwBBMB8GA1UdIwQYMBaAFA6sgmBAVieX5SUT
// SIG // /CrhClOVWeSkMFAGA1UdHwRJMEcwRaBDoEGGP2h0dHA6
// SIG // Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1
// SIG // Y3RzL21pY3Jvc29mdHJvb3RjZXJ0LmNybDBUBggrBgEF
// SIG // BQcBAQRIMEYwRAYIKwYBBQUHMAKGOGh0dHA6Ly93d3cu
// SIG // bWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljcm9zb2Z0
// SIG // Um9vdENlcnQuY3J0MA0GCSqGSIb3DQEBBQUAA4ICAQBZ
// SIG // OT5/Jkav629AsTK1ausOL26oSffrX3XtTDst10OtC/7L
// SIG // 6S0xoyPMfFCYgCFdrD0vTLqiqFac43C7uLT4ebVJcvc+
// SIG // 6kF/yuEMF2nLpZwgLfoLUMRWzS3jStK8cOeoDaIDpVbg
// SIG // uIpLV/KVQpzx8+/u44YfNDy4VprwUyOFKqSCHJPilAcd
// SIG // 8uJO+IyhyugTpZFOyBvSj3KVKnFtmxr4HPBT1mfMIv9c
// SIG // Hc2ijL0nsnljVkSiUc356aNYVt2bAkVEL1/02q7UgjJu
// SIG // /KSVE+Traeepoiy+yCsQDmWOmdv1ovoSJgllOJTxeh9K
// SIG // u9HhVujQeJYYXMk1Fl/dkx1Jji2+rTREHO4QFRoAXd01
// SIG // WyHOmMcJ7oUOjE9tDhNOPXwpSJxy0fNsysHscKNXkld9
// SIG // lI2gG0gDWvfPo2cKdKU27S0vF8jmcjcS9G+xPGeC+VKy
// SIG // jTMWZR4Oit0Q3mT0b85G1NMX6XnEBLTT+yzfH4qerAr7
// SIG // EydAreT54al/RrsHYEdlYEBOsELsTu2zdnnYCjQJbRyA
// SIG // MR/iDlTd5aH75UcQrWSY/1AWLny/BSF64pVBJ2nDk4+V
// SIG // yY3YmyGuDVyc8KKuhmiDDGotu3ZrAB2WrfIWe/YWgyS5
// SIG // iM9qqEcxL5rc43E91wB+YkfRzojJuBj6DnKNwaM9rwJA
// SIG // av9pm5biEKgQtDdQCNbDPTCCBgcwggPvoAMCAQICCmEW
// SIG // aDQAAAAAABwwDQYJKoZIhvcNAQEFBQAwXzETMBEGCgmS
// SIG // JomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1p
// SIG // Y3Jvc29mdDEtMCsGA1UEAxMkTWljcm9zb2Z0IFJvb3Qg
// SIG // Q2VydGlmaWNhdGUgQXV0aG9yaXR5MB4XDTA3MDQwMzEy
// SIG // NTMwOVoXDTIxMDQwMzEzMDMwOVowdzELMAkGA1UEBhMC
// SIG // VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcT
// SIG // B1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jw
// SIG // b3JhdGlvbjEhMB8GA1UEAxMYTWljcm9zb2Z0IFRpbWUt
// SIG // U3RhbXAgUENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
// SIG // MIIBCgKCAQEAn6Fssd/bSJIqfGsuGeG94uPFmVEjUK3O
// SIG // 3RhOJA/u0afRTK10MCAR6wfVVJUVSZQbQpKumFwwJtoA
// SIG // a+h7veyJBw/3DgSY8InMH8szJIed8vRnHCz8e+eIHern
// SIG // TqOhwSNTyo36Rc8J0F6v0LBCBKL5pmyTZ9co3EZTsIbQ
// SIG // 5ShGLieshk9VUgzkAyz7apCQMG6H81kwnfp+1pez6CGX
// SIG // fvjSE/MIt1NtUrRFkJ9IAEpHZhEnKWaol+TTBoFKovmE
// SIG // pxFHFAmCn4TtVXj+AZodUAiFABAwRu233iNGu8QtVJ+v
// SIG // HnhBMXfMm987g5OhYQK1HQ2x/PebsgHOIktU//kFw8Ig
// SIG // CwIDAQABo4IBqzCCAacwDwYDVR0TAQH/BAUwAwEB/zAd
// SIG // BgNVHQ4EFgQUIzT42VJGcArtQPt2+7MrsMM1sw8wCwYD
// SIG // VR0PBAQDAgGGMBAGCSsGAQQBgjcVAQQDAgEAMIGYBgNV
// SIG // HSMEgZAwgY2AFA6sgmBAVieX5SUT/CrhClOVWeSkoWOk
// SIG // YTBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZIm
// SIG // iZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNy
// SIG // b3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHmC
// SIG // EHmtFqFKoKWtTHNY9AcTLmUwUAYDVR0fBEkwRzBFoEOg
// SIG // QYY/aHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9j
// SIG // cmwvcHJvZHVjdHMvbWljcm9zb2Z0cm9vdGNlcnQuY3Js
// SIG // MFQGCCsGAQUFBwEBBEgwRjBEBggrBgEFBQcwAoY4aHR0
// SIG // cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9N
// SIG // aWNyb3NvZnRSb290Q2VydC5jcnQwEwYDVR0lBAwwCgYI
// SIG // KwYBBQUHAwgwDQYJKoZIhvcNAQEFBQADggIBABCXisNc
// SIG // A0Q23em0rXfbznlRTQGxLnRxW20ME6vOvnuPuC7UEqKM
// SIG // bWK4VwLLTiATUJndekDiV7uvWJoc4R0Bhqy7ePKL0Ow7
// SIG // Ae7ivo8KBciNSOLwUxXdT6uS5OeNatWAweaU8gYvhQPp
// SIG // kSokInD79vzkeJkuDfcH4nC8GE6djmsKcpW4oTmcZy3F
// SIG // UQ7qYlw/FpiLID/iBxoy+cwxSnYxPStyC8jqcD3/hQoT
// SIG // 38IKYY7w17gX606Lf8U1K16jv+u8fQtCe9RTciHuMMq7
// SIG // eGVcWwEXChQO0toUmPU8uWZYsy0v5/mFhsxRVuidcJRs
// SIG // rDlM1PZ5v6oYemIp76KbKTQGdxpiyT0ebR+C8AvHLLvP
// SIG // Q7Pl+ex9teOkqHQ1uE7FcSMSJnYLPFKMcVpGQxS8s7Ow
// SIG // TWfIn0L/gHkhgJ4VMGboQhJeGsieIiHQQ+kr6bv0SMws
// SIG // 1NgygEwmKkgkX1rqVu+m3pmdyjpvvYEndAYR7nYhv5uC
// SIG // wSdUtrFqPYmhdmG0bqETpr+qR/ASb/2KMmyy/t9RyIwj
// SIG // yWa9nR2HEmQCPS2vWY+45CHltbDKY7R4VAXUQS5QrJSw
// SIG // pXirs6CWdRrZkocTdSIvMqgIbqBbjCW/oO+EyiHW6x5P
// SIG // yZruSeD3AWVviQt9yGnI5m7qp5fOMSn/DsVbXNhNG6HY
// SIG // +i+ePy5VFmvJE6P9MYIElzCCBJMCAQEwgZAweTELMAkG
// SIG // A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO
// SIG // BgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29m
// SIG // dCBDb3Jwb3JhdGlvbjEjMCEGA1UEAxMaTWljcm9zb2Z0
// SIG // IENvZGUgU2lnbmluZyBQQ0ECEzMAAAFAlqnucFb+zAcA
// SIG // AQAAAUAwCQYFKw4DAhoFAKCBsDAZBgkqhkiG9w0BCQMx
// SIG // DAYKKwYBBAGCNwIBBDAcBgorBgEEAYI3AgELMQ4wDAYK
// SIG // KwYBBAGCNwIBFTAjBgkqhkiG9w0BCQQxFgQUgdhVPGB5
// SIG // iHEzQBn0vuoPE47WKjcwUAYKKwYBBAGCNwIBDDFCMECg
// SIG // JoAkAHMAdABvAHIAYQBnAGUAUAByAG8AdgBpAGQAZQBy
// SIG // AC4AagBzoRaAFGh0dHA6Ly9taWNyb3NvZnQuY29tMA0G
// SIG // CSqGSIb3DQEBAQUABIIBAEIFio0nPE9d/Wf1tg8iDjTM
// SIG // 39USYrafMFjckSxvVXzf5lLC3na++9RPxKBScTxjjgYU
// SIG // fIg6hOVpisckKHJIrSZGHzXGNhB7MH6iAxdSBkgLj9DG
// SIG // wB51Lak09+CqjlTlsp8JydvqMwvTepWmy4HB1AobvCjC
// SIG // EAqd+HlOj0OsQ7pJZKEHKHTeClZjeCyjE16yHUPucIv2
// SIG // U9lKTAtVXewTRXYPIkTaThscmwyZ8MHFVn3tZ637dMcA
// SIG // rHPWPCXfByPnZhGl9ClQhJydqHOJghQV2Dt7LOtFJyDE
// SIG // 3YMOD4W3u9sG/Wgs3/r9XAa9T5BStlQ96Eb23uLp/3Qq
// SIG // 3SJlRqJ7uB2hggIoMIICJAYJKoZIhvcNAQkGMYICFTCC
// SIG // AhECAQEwgY4wdzELMAkGA1UEBhMCVVMxEzARBgNVBAgT
// SIG // Cldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAc
// SIG // BgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEhMB8G
// SIG // A1UEAxMYTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBAhMz
// SIG // AAAAxniANgF1GmlyAAAAAADGMAkGBSsOAwIaBQCgXTAY
// SIG // BgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3
// SIG // DQEJBTEPFw0xNzA2MTIyMjU1MDFaMCMGCSqGSIb3DQEJ
// SIG // BDEWBBQD2WxDbEJeHHQ4V+j/JuWx3kkFdjANBgkqhkiG
// SIG // 9w0BAQUFAASCAQBDUIU1DzIjxf6QFrqhwKla65YHiFeV
// SIG // 1flXiBMaPCzcOytlx4pUIbJrXg1LgX7bccVzs1ROf9dw
// SIG // 1gRxN6TXKzS1gTqgeompa6caj59BNnsKUe2q6k6mSzpc
// SIG // 9xpz2BAyk+jFiFJQd0yeP4u4ypQimN7eWeru8JvlQop8
// SIG // wvdpdoeeIyokAkqqJyp/2vnrmXjPhJD9O6yn4fHpZoXx
// SIG // N7+neaCnuvShlgKtRaz0pMoULAG5i6AQqytOW60Aqc0J
// SIG // wK62qFBx+dQYJorlgSz83nW2JJFiaOQmZssAYIPeodvT
// SIG // D4AY+aMj7imSgE4+4+snGFSQiouuRaEp+nik+s0J/wf5
// SIG // DLUi
// SIG // End signature block
